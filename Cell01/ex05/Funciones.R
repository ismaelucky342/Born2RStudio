                                                                                                                                                                                                                      #                                                                                                                                                                                       dddddddd                         
#BBBBBBBBBBBBBBBBB                                                           222222222222222    RRRRRRRRRRRRRRRRR      SSSSSSSSSSSSSSS      tttt                                        d::::::d  iiii                   
#B::::::::::::::::B                                                         2:::::::::::::::22  R::::::::::::::::R   SS:::::::::::::::S  ttt:::t                                        d::::::d i::::i                  
#B::::::BBBBBB:::::B                                                        2::::::222222:::::2 R::::::RRRRRR:::::R S:::::SSSSSS::::::S  t:::::t                                        d::::::d  iiii                   
#BB:::::B     B:::::B                                                       2222222     2:::::2 RR:::::R     R:::::RS:::::S     SSSSSSS  t:::::t                                        d:::::d                          
#  B::::B     B:::::B   ooooooooooo   rrrrr   rrrrrrrrr   nnnn  nnnnnnnn                2:::::2   R::::R     R:::::RS:::::S        ttttttt:::::ttttttt    uuuuuu    uuuuuu      ddddddddd:::::d iiiiiii    ooooooooooo   
#  B::::B     B:::::B oo:::::::::::oo r::::rrr:::::::::r  n:::nn::::::::nn              2:::::2   R::::R     R:::::RS:::::S        t:::::::::::::::::t    u::::u    u::::u    dd::::::::::::::d i:::::i  oo:::::::::::oo 
#  B::::BBBBBB:::::B o:::::::::::::::or:::::::::::::::::r n::::::::::::::nn          2222::::2    R::::RRRRRR:::::R  S::::SSSS     t:::::::::::::::::t    u::::u    u::::u   d::::::::::::::::d  i::::i o:::::::::::::::o
#  B:::::::::::::BB  o:::::ooooo:::::orr::::::rrrrr::::::rnn:::::::::::::::n    22222::::::22     R:::::::::::::RR    SS::::::SSSSStttttt:::::::tttttt    u::::u    u::::u  d:::::::ddddd:::::d  i::::i o:::::ooooo:::::o
#  B::::BBBBBB:::::B o::::o     o::::o r:::::r     r:::::r  n:::::nnnn:::::n  22::::::::222       R::::RRRRRR:::::R     SSS::::::::SS    t:::::t          u::::u    u::::u  d::::::d    d:::::d  i::::i o::::o     o::::o
#  B::::B     B:::::Bo::::o     o::::o r:::::r     rrrrrrr  n::::n    n::::n 2:::::22222          R::::R     R:::::R       SSSSSS::::S   t:::::t          u::::u    u::::u  d:::::d     d:::::d  i::::i o::::o     o::::o
#  B::::B     B:::::Bo::::o     o::::o r:::::r              n::::n    n::::n2:::::2               R::::R     R:::::R            S:::::S  t:::::t          u::::u    u::::u  d:::::d     d:::::d  i::::i o::::o     o::::o
#  B::::B     B:::::Bo::::o     o::::o r:::::r              n::::n    n::::n2:::::2               R::::R     R:::::R            S:::::S  t:::::t    ttttttu:::::uuuu:::::u  d:::::d     d:::::d  i::::i o::::o     o::::o
#BB:::::BBBBBB::::::Bo:::::ooooo:::::o r:::::r              n::::n    n::::n2:::::2       222222RR:::::R     R:::::RSSSSSSS     S:::::S  t::::::tttt:::::tu:::::::::::::::uud::::::ddddd::::::ddi::::::io:::::ooooo:::::o
#B:::::::::::::::::B o:::::::::::::::o r:::::r              n::::n    n::::n2::::::2222222:::::2R::::::R     R:::::RS::::::SSSSSS:::::S  tt::::::::::::::t u:::::::::::::::u d:::::::::::::::::di::::::io:::::::::::::::o
#B::::::::::::::::B   oo:::::::::::oo  r:::::r              n::::n    n::::n2::::::::::::::::::2R::::::R     R:::::RS:::::::::::::::SS     tt:::::::::::tt  uu::::::::uu:::u  d:::::::::ddd::::di::::::i oo:::::::::::oo 
#BBBBBBBBBBBBBBBBB      ooooooooooo    rrrrrrr              nnnnnn    nnnnnn22222222222222222222RRRRRRRR     RRRRRRR SSSSSSSSSSSSSSS         ttttttttttt      uuuuuuuu  uuuu   ddddddddd   dddddiiiiiiii   ooooooooooo   
#                                                                                                                                                                                                                        
#                                                                                                               Ismael Hernández Clemente - ismael.hernandez@live.u-tad.com | ismherna@student.42madrid.com - 06/11/2024                                                                                                                           
## Mi primera función
## - Definición

myFun <- function(x, y)
{
    x + y
}


## - Argumentos

formals(myFun)


## - Cuerpo

body(myFun)

## Mi primera función

myFun(1, 2)

myFun(1:10, 21:30)

myFun(1:10, 3)

## Argumentos: nombre y orden

## Una función identifica sus argumentos por su nombre y por su orden (sin nombre)


power <- function(x, exp)
{
    x^exp
}

power(x=1:10, exp=2)

power(1:10, exp=2)

power(exp=2, x=1:10)

## Argumentos: valores por defecto
## - Se puede asignar un valor por defecto a los argumentos

power <- function(x, exp = 2)
{
    x ^ exp
}

power(1:10)

power(1:10, 2)

## Funciones sin argumentos

hello <- function()
{
    print('Hello world!')
}

hello()

## Argumentos sin nombre: =...=

pwrSum <- function(x, power, ...)
{
    sum(x ^ power, ...)
}

x <- 1:10
pwrSum(x, 2)

x <- c(1:5, NA, 6:9, NA, 10)
pwrSum(x, 2)

pwrSum(x, 2, na.rm=TRUE)

## Argumentos ausentes: =missing=

suma10 <- function(x, y)
{
    if (missing(y)) y <- 10
    x + y
}

suma10(1:10)

## Control de errores: =stopifnot=

foo <- function(x, y)
{
    stopifnot(is.numeric(x) & is.numeric(y))
    x + y
}

foo(1:10, 21:30)

foo(1:10, 'a')

## Control de errores: =stop=

foo <- function(x, y){
    if (!(is.numeric(x) & is.numeric(y))){
        stop('arguments must be numeric.')
    } else { x + y }
}

foo(2, 3)

foo(2, 'a')

## Mensajes para el usuario
## =stop= para la ejecución y emite un mensaje de error

stop('Algo no ha ido bien.')


## =warning= no interfiere en la ejecución pero añade un mensaje a la cola de advertencias

warning('Quizás algo no es como debiera...')


## =message= emite un mensaje (*no usar =cat= o =print=*)

message('Todo en orden por estos lares.')

## Clases de variables
## Las variables que se emplean en el cuerpo de una función pueden
## dividirse en:
##   - Parámetros formales (argumentos): =x=, =y=
##   - Variables locales (definiciones internas): =z=, =w=, =m=
##   - Variables libres: =a=, =b=

myFun <- function(x, y){
    z <- x^2
    w <- y^3
    m <- a*z + b*w
    m
}

a <- 10
b <- 20
myFun(2, 3)

## Lexical scope

## - Las variables libres deben estar disponibles en el entorno
##   (=environment=) en el que la función ha sido creada.

environment(myFun)

ls()

## Lexical scope: funciones anidadas

anidada <- function(x, y){
    xn <- 2
    yn <- 3
    interna <- function(x, y)
    {
        sum(x^xn, y^yn)
    }
    print(environment(interna))
    interna(x, y)
}

anidada(1:3, 2:4)

sum((1:3)^2, (2:4)^3)

## Lexical scope: funciones anidadas

xn

yn

interna

## Funciones que devuelven funciones

constructor <- function(m, n){
    function(x)
    {
        m*x + n
    }
}

myFoo <- constructor(10, 3)
myFoo

## 10*5 + 3
myFoo(5)

## Funciones que devuelven funciones

class(myFoo)

environment(myFoo)

ls()

ls(env = environment(myFoo))

get('m', env = environment(myFoo))

get('n', env = environment(myFoo))

## =lapply=
## Supongamos que tenemos una lista de objetos, y queremos aplicar a cada elemento la misma función:

lista <- list(a = rnorm(100),
              b = runif(100),
              c = rexp(100))


## Podemos resolverlo de forma repetitiva...

sum(lista$a)

sum(lista$b)

sum(lista$c)



## O mejor con =lapply= (lista + función):

lapply(lista, sum)

## =do.call=
## Supongamos que queremos usar los elementos de la lista como argumentos de una función.

## Resolvemos de forma directa:

sum(lista$a, lista$b, lista$c)


## Mejoramos /un poco/ con =with=:

with(lista, sum(a, b, c))


## La forma recomendable es mediante =do.call= (función + lista)

do.call(sum, lista)

## =do.call=

## Se emplea frecuentemente para adecuar el resultado de =lapply= (entrega una lista):

  x <- rnorm(5)
  ll <- lapply(1:5, function(i)x^i)
  do.call(rbind, ll)

## =Reduce=
## Combina sucesivamente los elementos de un objeto aplicando una función binaria

## (((1+2)+3)+4)+5
Reduce('+', 1:5)

## =Reduce=

## (((1/2)/3)/4)/5
Reduce('/', 1:5)

foo <- function(u, v)u + 1 /v
Reduce(foo, c(3, 7, 15, 1, 292))
## equivalente a
## foo(foo(foo(foo(3, 7), 15), 1), 292)

Reduce(foo, c(3, 7, 15, 1, 292), right=TRUE)
## equivalente a
## foo(3, foo(7, foo(15, foo(1, 292))))

## Funciones recursivas
## Ejemplo: [[http://en.wikibooks.org/wiki/R_Programming/Working_with_functions#Functions_as_Objects][Serie de Fibonnaci]]

fib <- function(n){
    if (n>2) {
        c(fib(n-1),
          sum(tail(fib(n-1),2)))
    } else if (n>=0) rep(1,n)
}

fib(10)

## Post-mortem: =traceback=

sumSq <- function(x, ...)
    sum(x ^ 2, ...)

sumProd <- function(x, y, ...){
    xs <- sumSq(x, ...)
    ys <- sumSq(y, ...)
    xs * ys
}

sumProd(rnorm(10), runif(10))

sumProd(rnorm(10), letters[1:10])

traceback()

## Analizar antes de que ocurra: =debug=
## =debug= activa la ejecución paso a paso de una función:

debug(sumProd)


## - Cada vez que se llame a la función, su cuerpo se ejecuta línea a línea y los resultados de cada paso pueden ser inspeccionados.
## - Los comandos disponibles son:
##   - =n= o intro: avanzar un paso.
##   - =c=: continua hasta el final del contexto actual (por ejemplo,
##     terminar un bucle).
##   - =where=: entrega la lista de todas las llamadas activas.
##   - =Q=: termina la inspección y vuelve al nivel superior.
## - Para desactivar el análisis:

undebug(sumProd)

## /Debugging/ con RStudio
##   - [[https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio][Artículo]]
##   - [[https://vimeo.com/99375765https://vimeo.com/97831988][Vídeo]]
## - [[http://adv-r.had.co.nz/Exceptions-Debugging.html][/Debugging/ explicado por H. Wickham]]

## - Ejemplo: grabar en un fichero y usar /source/

sumSq <- function(x, ...)
    sum(x ^ 2, ...)

sumProd <- function(x, y, ...){
    xs <- sumSq(x, ...)
    ys <- sumSq(y, ...)
    xs * ys
}

sumProd(rnorm(10), letters[1:10])

## Analizar antes de que ocurra: =trace=
## - =trace= permite mayor control que =debug=

trace(sumProd, tracer=browser, exit=browser)


## - La función queda modificada

sumProd

body(sumProd)

## Analizar antes de que ocurra: =trace=
## - Los comandos =n= y =c= cambian respecto a =debug=:
##   - =c= o intro: avanzar un paso.
##   - =n=: continua hasta el final del contexto actual (por ejemplo,
##     terminar un bucle).
## - Para desactivar

untrace(sumProd)

## ¿Cuánto tarda mi función? =system.time=
## Defino una función que rellena una matriz de 10^6 filas y =n= columnas con una distribución normal:

makeNoise <- function(n){
    sapply(seq_len(n), function(i) rnorm(1e6))
}

M <- makeNoise(100)
summary(M)

## Diferentes formas de sumar
## =system.time= mide el tiempo de CPU que consume un código[fn:1].


system.time({
    suma1 <- numeric(1e6)
    for(i in 1:1e6) suma1[i] <- sum(M[i,])
})

system.time(suma2 <- apply(M, 1, sum))

system.time(suma3 <- rowSums(M))

## ¿Cuánto tarda cada parte de mi función?: =Rprof=
## - Usaremos un fichero temporal

tmp <- tempfile()


## - Activamos la toma de información

Rprof(tmp)


## - Ejecutamos el código a analizar

suma1 <- numeric(1e6)
for(i in 1:1e6) suma1[i] <- sum(M[i,])

suma2 <- apply(M, 1, FUN = sum)

suma3 <- rowSums(M)

## ¿Cuánto tarda cada parte de mi función?: =Rprof=
## - Paramos el análisis

Rprof()


## - Extraemos el resumen

summaryRprof(tmp)
